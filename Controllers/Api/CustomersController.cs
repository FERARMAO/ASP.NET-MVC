using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using Vidly.Models;
using Vidly.DTOs;
using AutoMapper;
using System.Data.Entity;

namespace Vidly.Controllers.Api
{
    public class CustomersController : ApiController
    {
        private ApplicationDbContext _context;

        public CustomersController()
        {
            _context = new ApplicationDbContext();
        }
        //Because we're returning a list of objects, this action by covention will respond to : GET /api/customers.
        [Authorize]
        public IHttpActionResult GetCustomers(string query = null) //This is an action to get the list of the customers. //we added an optional parameter called: query. Our Typaahead Plugin is going to send that query parameter here.
        {
            var customersQuery = _context.Customers 
                .Include(c => c.MembershipType);

            if (!String.IsNullOrWhiteSpace(query))  //This is the filter to filter people by name & get the right records when we search.
                customersQuery = customersQuery.Where(c => c.Name.Contains(query)); 

            var customerDtos = customersQuery
                .ToList() //we call ToList() here because we didn't want the Query to be executed immediatly!
                .Select(Mapper.Map<Customer, CustomerDto>); //In Select(it's a Linq extension method) we've passed a delegate that does the mapping. Ps : i removed () because we're not going to call this method. if we call it, it gets executed but here we need to delegate a referece to this method.
           
            return Ok(customerDtos);
        }
        // GET /api/customers/1 
        [Authorize]
        public IHttpActionResult GetCustomer(int id)
        {
            var customer = _context.Customers.SingleOrDefault(c => c.Id == id);

            if (customer == null)
                return NotFound();

            return Ok(Mapper.Map<Customer, CustomerDto>(customer)); //Here we're returning one customer object, so we cannot use the select extension method of Linq like above! Instead we use this.
        }

        // POST /api/customers. By convention, when we create a resource, we return the newly created resource to the client. Because that resource will probably have an Id generated by the server.
        [HttpPost] //We put this because here we're creating a resource.so we're appliying this attribute here, this action will only be called if we send an Http Post request. alternatively we could name the action using a convention : PostCustomer, with this way we don't have to pute [HttpPost], but NOT GOOD!
        public IHttpActionResult CreateCustomer(CustomerDto customerDto) //This Little customerDto object wil be in the request body & ASP.NET Web API Framework will automatically initialize this.
        {
            if (!ModelState.IsValid)
                return BadRequest(); //This Badrequest method returns badrequest result.

            var customer = Mapper.Map<CustomerDto, Customer>(customerDto);
            _context.Customers.Add(customer);
            _context.SaveChanges(); //At this point, the Id property will be set based on the Id generated from the Db.
            customerDto.Id = customer.Id; //To add the customer's generated Id to customerDto, so after it is returned.
            return Created(new Uri(Request.RequestUri + "/" + customer.Id), customerDto ); //As part of RESTful convention, we need to return the URI of the newly created resource to the client. In the 2nd argument we need to pass the actual object that was created.
        } //C'est return Created qui donne la reponse 201. si Ok on aurait eu 200 ...etc.
        // PUT /api/customers/1
        [HttpPut]
        public IHttpActionResult UpdateCustomer(int id, CustomerDto customerDto) //id comes from URL, & customer from request body.
        {
            if (!ModelState.IsValid)
                return BadRequest();
            
            var customerInDb = _context.Customers.SingleOrDefault(c => c.Id == id);
            // we check here because it is possible that a client sends an invalid id, so we need to check for the existance of this object.
            if (customerInDb == null)
                return NotFound();
            Mapper.Map(customerDto, customerInDb); //In previous examples i didn't pass a 2nd argument to this method, so it created a new object and returned it. But if we have an existing object(CustomerDto), we can pass that here as a second argument.
            _context.SaveChanges();
            return Ok();
        }
        // DELETE /api/customers/1
        [HttpDelete]
        public IHttpActionResult DeleteCustomer(int id)
        {
            var customerInDb = _context.Customers.SingleOrDefault(c => c.Id == id);
            if (customerInDb == null)
                return NotFound();

            _context.Customers.Remove(customerInDb); //This object will be marked as removed in memory.
            _context.SaveChanges();
            return Ok();
        }
    }
}
